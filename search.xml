<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lecture 1 Introduction and Matrix Multiplication</title>
    <url>/2023/01/05/mit-6-172-1/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>略</p>
<h1 id="Matrix-Multiplication"><a href="#Matrix-Multiplication" class="headerlink" title="Matrix Multiplication"></a>Matrix Multiplication</h1><p>利用矩阵乘法介绍优化方案</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/MatrixMultiplication.png"
                     
                ></p>
<h3 id="采用-Python、Java、C-的运行时间不一样"><a href="#采用-Python、Java、C-的运行时间不一样" class="headerlink" title="采用 Python、Java、C 的运行时间不一样"></a>采用 Python、Java、C 的运行时间不一样</h3><p>Why is Python so slow and C so fast?</p>
<ul>
<li>Python is interpreted.</li>
<li>C is compiled directly to machine code.</li>
<li>Java is compiled to byte-code, which is then interpreted and just-in-time (JIT) compiled to machine code.</li>
</ul>
<h3 id="i、j、k-循环调换位置后运行时间不一样"><a href="#i、j、k-循环调换位置后运行时间不一样" class="headerlink" title="i、j、k 循环调换位置后运行时间不一样"></a>i、j、k 循环调换位置后运行时间不一样</h3><ul>
<li>cache hits 和 cache misses</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/ijk1.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/ijk2.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/ijk3.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/ijk4.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/ijk5.png"
                     
                ></p>
<h3 id="Clang-优化"><a href="#Clang-优化" class="headerlink" title="Clang 优化"></a>Clang 优化</h3><p>不一定 O3 优化比 O2 优化快，有时候 O2 快，有时候 O3 快</p>
<h3 id="Parallel-Loops"><a href="#Parallel-Loops" class="headerlink" title="Parallel Loops"></a>Parallel Loops</h3><p>The <strong>cilk_for</strong> loop allows all iterations of the loop to execute in parallel.</p>
<p>Rule of Thumb Parallelize outer loops rather than inner loops.</p>
<h3 id="进一步优化-重用数据（tiling）"><a href="#进一步优化-重用数据（tiling）" class="headerlink" title="进一步优化-重用数据（tiling）"></a>进一步优化-重用数据（tiling）</h3><ul>
<li>Restructure the computation to reuse data in the cache as much as possible. （Cache misses are slow, and cache hits are fast.）</li>
<li>Try to make the most of the cache by reusing the data that’s already there.</li>
</ul>
<h3 id="Parallel-divide-and-conquer"><a href="#Parallel-divide-and-conquer" class="headerlink" title="Parallel divide-and-conquer"></a>Parallel divide-and-conquer</h3><pre><code>cilk_spawn
/*
The child function call is spawned, meaning it may execute in parallel with the parent caller.
*/
cilk_sync
/*
Control may not pass this point until all spawned children have returned.
*/
</code></pre>
<h3 id="Compiler-Vectorization（编译矢量化）"><a href="#Compiler-Vectorization（编译矢量化）" class="headerlink" title="Compiler Vectorization（编译矢量化）"></a>Compiler Vectorization（编译矢量化）</h3><p>Many machines don’t support the newest set of vector instructions, however, so the compiler uses vector instructions conservatively by default</p>
<h3 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h3><ul>
<li>Preprocessing</li>
<li>Matrix transposition</li>
<li>Data alignment</li>
<li>Memory-management optimizations</li>
<li>A clever algorithm for the base case that uses AVX intrinsic instructions explicitly</li>
</ul>
<p>综上优化效果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-1/time.png"
                      alt="test"
                ></p>
]]></content>
      <tags>
        <tag>Performance Engineering Of Software Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 2 Bentley Rules for Optimizing Work</title>
    <url>/2023/01/07/mit-6-172-2/</url>
    <content><![CDATA[<h1 id="DATA-STRUCTURES"><a href="#DATA-STRUCTURES" class="headerlink" title="DATA STRUCTURES"></a>DATA STRUCTURES</h1><h3 id="Packing-and-Encoding"><a href="#Packing-and-Encoding" class="headerlink" title="Packing and Encoding"></a>Packing and Encoding</h3><p><strong>The idea of packing is to store more than one data value in a machine word. The related idea of encoding is to convert data values into a representation requiring fewer bits.</strong></p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Encoding dates</p>
<ul>
<li>The string “September 11, 2018” can be stored in 18 bytes — more than two double (64-bit) words which must moved whenever a date is manipulated.</li>
</ul>
<h4 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h4><ul>
<li>Assuming that we only store years between 4096 B.C.E. and 4096 C.E., there are about 365.25 × 8192 ≈ 3 M dates, which can be encoded in ⎡lg(3×106)⎤ &#x3D; 22 bits, easily fitting in a single (32-bit) word.</li>
</ul>
<p>But determining the month of a date takes more work than with the string representation.</p>
<ul>
<li><p>Instead，pack the three fields into a word</p>
<p>typedef struct{<br>int year: 13;<br>int month: 4;<br>int day: 5;<br>} date_t;</p>
</li>
<li><p>This packed representation still only takes 22 bits(Actually this will pack the struct a little bit at the end), but the individual fields can be extracted much more quickly than if we had encoded the 3 M dates as sequential integers</p>
</li>
</ul>
<p><strong>Sometimes unpacking and decoding are the optimization, depending on whether more work is involved moving the data or operating on it.</strong></p>
<h3 id="Augmentation"><a href="#Augmentation" class="headerlink" title="Augmentation"></a>Augmentation</h3><p><strong>The idea of data-structure augmentation is to add information to a data structure to make common operations do less work.</strong></p>
<ul>
<li>Appending singly linked lists</li>
</ul>
<h3 id="Precomputation"><a href="#Precomputation" class="headerlink" title="Precomputation"></a>Precomputation</h3><p><strong>The idea of precomputation is to perform calculations in advance so as to avoid doing them at “missioncritical” times.</strong></p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>Binomial coefficients<br>【Latex 公式！！！！！！！！！】</p>
<ul>
<li>Computing the “choose” function by implementing this formula can be expensive (lots of multiplications)</li>
<li>Watch out for <strong>integer overflow</strong> for even modest values of n and k.</li>
</ul>
<h4 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h4><p>Precompute the table of coefficients when initializing, and perform table look-up at runtime.</p>
<ul>
<li>Pascal’s Triangle<ul>
<li>vertical axis - n</li>
<li>horizontal axis - k</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/table1.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/table2.png"
                     
                ></p>
<h3 id="Compile-Time-Initialization"><a href="#Compile-Time-Initialization" class="headerlink" title="Compile-Time Initialization"></a>Compile-Time Initialization</h3><p><strong>The idea of compile-time initialization is to store the values of constants during compilation, saving work at execution time.</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/table3.png"
                     
                ></p>
<h4 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h4><p>Create large static tables by metaprogramming.（easier in Python）</p>
<h3 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h3><p><strong>The idea of caching is to store results that have been accessed recently so that the program need not compute them again.</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/cache.png"
                     
                ></p>
<ul>
<li>可以做大一点的 cache，这样搜索 cache 耗时会增加，但也可以节省运行时间</li>
<li>可以在软件上实现而不依靠硬件的 cache 来做</li>
</ul>
<h3 id="Sparsity"><a href="#Sparsity" class="headerlink" title="Sparsity"></a>Sparsity</h3><p><strong>The idea of exploiting sparsity is to avoid storing and computing on zeroes. “Thefastestwaytocomputeis nottocomputeatall.”</strong></p>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><p>Matrix-vector multiplication</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/matrix1.png"
                     
                ></p>
<h4 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h4><p>Compressed Sparse Row (稀疏矩阵的主要存储格式之一)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/matrix2.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/matrix3.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/matrix4.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/matrix5.png"
                     
                ></p>
<h1 id="LOGIC"><a href="#LOGIC" class="headerlink" title="LOGIC"></a>LOGIC</h1><h3 id="Constant-Folding-and-Propagation"><a href="#Constant-Folding-and-Propagation" class="headerlink" title="Constant Folding and Propagation"></a>Constant Folding and Propagation</h3><p><strong>The idea of constant folding and propagation is to evaluate constant expressions and substitute the result into further expressions, all during compilation.</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/CFaP1.png"
                     
                ></p>
<p><strong>With a sufficiently high optimization level, all the expressions are evaluated at compile-time.</strong></p>
<h3 id="Common-Subexpression-Elimination"><a href="#Common-Subexpression-Elimination" class="headerlink" title="Common-Subexpression Elimination"></a>Common-Subexpression Elimination</h3><p><strong>The idea of common-subexpression elimination is to avoid computing the same expression multiple times by evaluating the expression once and storing the result for later use.</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-2/CSE.png"
                     
                ></p>
<h3 id="Algebraic-Identities"><a href="#Algebraic-Identities" class="headerlink" title="Algebraic Identities"></a>Algebraic Identities</h3><p><strong>The idea of exploiting algebraic identities is to replace expensive algebraic expressions with algebraic equivalents that require less work.</strong></p>
<h3 id="Short-Circuiting"><a href="#Short-Circuiting" class="headerlink" title="Short-Circuiting"></a>Short-Circuiting</h3><p><strong>When performing a series of tests, the idea of shortcircuiting is to stop evaluating as soon as you know the answer.</strong></p>
<p>&amp;&amp; ||</p>
<h3 id="Ordering-Tests"><a href="#Ordering-Tests" class="headerlink" title="Ordering Tests"></a>Ordering Tests</h3><p><strong>Consider code that executes a sequence of logical tests. The idea of ordering tests is to perform those that are more often “successful” — a particular alternative is selected by the test — before tests that are rarely successful. Similarly, inexpensive tests should precede expensive ones.</strong></p>
<h3 id="Creating-a-Fast-Path"><a href="#Creating-a-Fast-Path" class="headerlink" title="Creating a Fast Path"></a>Creating a Fast Path</h3><h3 id="Combining-Tests"><a href="#Combining-Tests" class="headerlink" title="Combining Tests"></a>Combining Tests</h3><p><strong>The idea of combining tests is to replace a sequence of tests with one test or switch.</strong></p>
<p>Switch</p>
<h1 id="LOOPS"><a href="#LOOPS" class="headerlink" title="LOOPS"></a>LOOPS</h1><h3 id="Hoisting-循环不变代码外移"><a href="#Hoisting-循环不变代码外移" class="headerlink" title="Hoisting 循环不变代码外移"></a>Hoisting 循环不变代码外移</h3><p><strong>The goal of hoisting — also called loop-invariant code motion — is to avoid recomputing loop-invariant code each time through the body of a loop.</strong></p>
<h3 id="Sentinels-简化循环边界条件"><a href="#Sentinels-简化循环边界条件" class="headerlink" title="Sentinels 简化循环边界条件"></a>Sentinels 简化循环边界条件</h3><p><strong>Sentinels are special dummy values placed in a data structure to simplify the logic of boundary conditions, and in particular, the handling of loop-exit tests.</strong></p>
<h3 id="Loop-Unrolling-循环展开"><a href="#Loop-Unrolling-循环展开" class="headerlink" title="Loop Unrolling 循环展开"></a>Loop Unrolling 循环展开</h3><p><strong>Loop unrolling attempts to save work by combining several consecutive iterations of a loop into a single iteration, thereby reducing the total number of iterations of the loop and, consequently, the number of times that the instructions that control the loop must be executed.</strong></p>
<ul>
<li>Full loop unrolling: All iterations are unrolled.</li>
<li>Partial loop unrolling: Several, but not all, of the iterations are unrolled.</li>
</ul>
<h3 id="Loop-Fusion-循环合并"><a href="#Loop-Fusion-循环合并" class="headerlink" title="Loop Fusion 循环合并"></a>Loop Fusion 循环合并</h3><p><strong>The idea of loop fusion — also called jamming — is to combine multiple loops over the same index range into a single loop body, thereby saving the overhead of loop control.</strong></p>
<h3 id="Eliminating-Wasted-Iterations-消除浪费的迭代"><a href="#Eliminating-Wasted-Iterations-消除浪费的迭代" class="headerlink" title="Eliminating Wasted Iterations 消除浪费的迭代"></a>Eliminating Wasted Iterations 消除浪费的迭代</h3><p><strong>The idea of eliminating wasted iterations is to modify loop bounds to avoid executing loop iterations over essentially empty loop bodies.</strong></p>
<h1 id="FUNCTIONS"><a href="#FUNCTIONS" class="headerlink" title="FUNCTIONS"></a>FUNCTIONS</h1><h3 id="Inlining"><a href="#Inlining" class="headerlink" title="Inlining"></a>Inlining</h3><p><strong>The idea of inlining is to avoid the overhead of a function call by replacing a call to the function with the body of the function itself.</strong></p>
<ul>
<li>直接写入函数</li>
<li>static inline 内联函数</li>
</ul>
<h3 id="Tail-Recursion-Elimination-尾调用优化"><a href="#Tail-Recursion-Elimination-尾调用优化" class="headerlink" title="Tail-Recursion Elimination 尾调用优化"></a>Tail-Recursion Elimination 尾调用优化</h3><p><strong>The idea of tail-recursion elimination is to replace a recursive call that occurs as the last step of a function with a branch, saving function-call overhead.</strong></p>
<h3 id="Coarsening-Recursion-粗化递归"><a href="#Coarsening-Recursion-粗化递归" class="headerlink" title="Coarsening Recursion 粗化递归"></a>Coarsening Recursion 粗化递归</h3><p><strong>The idea of coarsening recursion is to increase the size of the base case and handle it with more efficient code that avoids function-call overhead.</strong></p>
<h4 id="Chapgpt-对粗化递归的一个例子"><a href="#Chapgpt-对粗化递归的一个例子" class="headerlink" title="Chapgpt 对粗化递归的一个例子"></a>Chapgpt 对粗化递归的一个例子</h4><p>粗化递归是一种优化技术，它通过减少递归调用的次数来提高运行速度。这通常是通过在每次递归调用之间执行更多的工作来实现的。</p>
<p>例如，考虑一个用于计算阶乘的简单递归函数：<br>def factorial(n):<br>if n &#x3D;&#x3D; 1:<br>return 1<br>else:<br>return n * factorial(n - 1)</p>
<p>这个函数每次递归调用都会执行一次乘法运算。我们可以对它进行粗化递归优化，使其在每次递归调用之间执行多次乘法运算，从而减少递归调用的次数：</p>
<pre><code>def factorial(n):
result = 1
while n &gt; 1:
    result *= n
    n -= 1
return result
</code></pre>
<p>这个优化后的函数只会执行一次递归调用，因此它的运行速度会快得多。</p>
<p>当然，粗化递归并不是每个情况下都能使用的，它只适用于一些特定的问题。但是，当适用时，它可以显著提高运行速度。</p>
<h1 id="Closing-Advice"><a href="#Closing-Advice" class="headerlink" title="Closing Advice"></a>Closing Advice</h1><ul>
<li>Avoid premature optimization. First get correct working code. Then optimize, preserving correctness by regression testing.</li>
<li>Reducing the work of a program does not necessarily decrease its running time, but it is a good heuristic.</li>
<li>The compiler automates many low-level optimizations.</li>
<li>To tell if the compiler is actually performing a particular optimization, look at the assembly code.</li>
</ul>
<h1 id="英语词汇笔记"><a href="#英语词汇笔记" class="headerlink" title="英语词汇笔记"></a>英语词汇笔记</h1><table>
<thead>
<tr>
<th>单词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>excuse</td>
<td>执行（代码）</td>
</tr>
<tr>
<td>Algorithm</td>
<td>算法</td>
</tr>
<tr>
<td>DATA STRUCTURES</td>
<td>数据结构</td>
</tr>
<tr>
<td>encode</td>
<td>编码</td>
</tr>
<tr>
<td>manipulate</td>
<td>操作</td>
</tr>
<tr>
<td>Augmentation</td>
<td>增强</td>
</tr>
<tr>
<td>Precomputation</td>
<td>预计算</td>
</tr>
<tr>
<td>Binomial coefficients</td>
<td>二项分布 系数</td>
</tr>
<tr>
<td>implemente</td>
<td>执行（公式）</td>
</tr>
<tr>
<td>formula</td>
<td>公式</td>
</tr>
<tr>
<td>perform</td>
<td>执行（操作）</td>
</tr>
<tr>
<td>compile</td>
<td>编译</td>
</tr>
<tr>
<td>metaprogramming</td>
<td>元编程</td>
</tr>
<tr>
<td>Sparsity</td>
<td>稀疏的</td>
</tr>
<tr>
<td>Constant Folding</td>
<td>常数折叠（编译器优化的一种技术）</td>
</tr>
<tr>
<td>Constant Propagation</td>
<td>常数传播（编译器优化的一种技术）</td>
</tr>
<tr>
<td>optimization</td>
<td>最优化</td>
</tr>
<tr>
<td>common-subexpression</td>
<td>公因子表达式</td>
</tr>
<tr>
<td>elimination</td>
<td>剔除</td>
</tr>
<tr>
<td>Algebraic Identities</td>
<td>代数恒等式</td>
</tr>
<tr>
<td>iteration</td>
<td>迭代</td>
</tr>
<tr>
<td>Recursion</td>
<td>递归</td>
</tr>
<tr>
<td>heuristic</td>
<td>（计算机程序或教育中的）启发式方法</td>
</tr>
<tr>
<td>assembly code</td>
<td>汇编代码</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Performance Engineering Of Software Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 3 Bit Hacks</title>
    <url>/2023/01/08/mit-6-172-3/</url>
    <content><![CDATA[<h1 id="Bit-Hacks"><a href="#Bit-Hacks" class="headerlink" title="Bit Hacks"></a>Bit Hacks</h1><h3 id="二进制表示"><a href="#二进制表示" class="headerlink" title="二进制表示"></a>二进制表示</h3><p>略</p>
<h3 id="反补码性质"><a href="#反补码性质" class="headerlink" title="反补码性质"></a>反补码性质</h3><p>略</p>
<h3 id="八进制、十六进制"><a href="#八进制、十六进制" class="headerlink" title="八进制、十六进制"></a>八进制、十六进制</h3><p>略</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>略</p>
<h3 id="Set-the-kth-Bit"><a href="#Set-the-kth-Bit" class="headerlink" title="Set the kth Bit"></a>Set the k<sup>th</sup> Bit</h3><pre><code>y = x | (1 &lt;&lt; k);
</code></pre>
<h3 id="Clear-the-kth-Bit"><a href="#Clear-the-kth-Bit" class="headerlink" title="Clear the kth Bit"></a>Clear the k<sup>th</sup> Bit</h3><pre><code>y = x &amp;(1 &lt;&lt; k);
</code></pre>
<h3 id="Toggle-the-kth-Bit"><a href="#Toggle-the-kth-Bit" class="headerlink" title="Toggle the kth Bit"></a>Toggle the k<sup>th</sup> Bit</h3><pre><code>y = x ^ (1 &lt;&lt; k);
</code></pre>
<h3 id="Extract-a-Bit-Field"><a href="#Extract-a-Bit-Field" class="headerlink" title="Extract a Bit Field"></a>Extract a Bit Field</h3><pre><code>(x % mask) &gt;&gt; shift;
//mask 将待抽取的位 置一
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/extract1.png"
                     
                ></p>
<h3 id="Set-a-Bit-Field"><a href="#Set-a-Bit-Field" class="headerlink" title="Set a Bit Field"></a>Set a Bit Field</h3><pre><code>x = (x &amp; ~mask) | (y &lt;&lt; shift);
//For safety’s sake:((y &lt;&lt; shift) &amp; mask)
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/set1.png"
                     
                ></p>
<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><ul>
<li><h4 id="Ordinary-Swap"><a href="#Ordinary-Swap" class="headerlink" title="Ordinary Swap"></a>Ordinary Swap</h4><pre><code>  t = x;
  x = y;
  y = t;
</code></pre>
</li>
<li><h4 id="No-Temp-Swap"><a href="#No-Temp-Swap" class="headerlink" title="No-Temp Swap"></a>No-Temp Swap</h4><pre><code>  x = x ^ y;
  y = x ^ y;
  x = x ^ y;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/swap1.png"
                     
                ></p>
<p><strong>Why it works</strong> : XOR is its own inverse (x ^ y) ^ y &#x3D; x</p>
<p><strong>Performance</strong> : poor at exploiting instruction-level parallelism(slower than the original code)</p>
</li>
</ul>
<h3 id="Minimum-of-Two-Integers"><a href="#Minimum-of-Two-Integers" class="headerlink" title="Minimum of Two Integers"></a>Minimum of Two Integers</h3><ul>
<li><h4 id="Ordinary-Minimum"><a href="#Ordinary-Minimum" class="headerlink" title="Ordinary Minimum"></a>Ordinary Minimum</h4><pre><code>  r = (x &lt; y) ? x : y;
</code></pre>
<p><strong>Performance</strong> : A mispredicted branch empties the processor pipeline<br><strong>Caveat</strong> : The compiler is usually smart enough to optimize away the unpredictable branch, but maybe not.</p>
</li>
<li><h4 id="No-Branch-Minimum"><a href="#No-Branch-Minimum" class="headerlink" title="No-Branch Minimum"></a>No-Branch Minimum</h4><pre><code>  r = y ^ ((x ^ y) &amp; -(x &lt; y));
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/min1.png"
                     
                ></p>
</li>
</ul>
<h3 id="Merging-Two-Sorted-Arrays"><a href="#Merging-Two-Sorted-Arrays" class="headerlink" title="Merging Two Sorted Arrays"></a>Merging Two Sorted Arrays</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/merge1.png"
                     
                ></p>
<p><strong>if branch is predictable</strong>: most of the time it retrun true, and once it return false you are never going to look at that again.<br>it is predictable &#x3D; it can do prefetching efficiently</p>
<h4 id="Modular-Additon"><a href="#Modular-Additon" class="headerlink" title="Modular Additon"></a>Modular Additon</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_30.png"
                     
                ></p>
<ul>
<li>n 是 2 的幂</li>
<li>z 可能小于 n</li>
<li>同 minimum 方法</li>
</ul>
<h4 id="Round-up-to-a-Power-of-2"><a href="#Round-up-to-a-Power-of-2" class="headerlink" title="Round up to a Power of 2"></a>Round up to a Power of 2</h4><p>进一至 2 的幂次<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_31.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_41.png"
                     
                ></p>
<ul>
<li>注意向右填充所有位的方法</li>
</ul>
<ul>
<li>这是一种处理边界条件的方法</li>
</ul>
<h4 id="Least-Significant-1"><a href="#Least-Significant-1" class="headerlink" title="Least-Significant 1"></a>Least-Significant 1</h4><p>最小的 1<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_43.png"
                     
                ></p>
<h4 id="Log-Base-2-of-a-Power-of-2"><a href="#Log-Base-2-of-a-Power-of-2" class="headerlink" title="Log Base 2 of a Power of 2"></a>Log Base 2 of a Power of 2</h4><p>课堂表演魔术-利用德布鲁因序列的数学性质</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_44.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_46.png"
                     
                ></p>
<ul>
<li>德布鲁因序列</li>
</ul>
<h4 id="n-Queens-Problem"><a href="#n-Queens-Problem" class="headerlink" title="n Queens Problem"></a>n Queens Problem</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_47.png"
                     
                ></p>
<ul>
<li>每一行从左往右试 符合就下一行。若都不符合就上一行继续往后试</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_58.png"
                     
                ></p>
<ul>
<li>三个向量 分别对应下文三图</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_59.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_60.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_61.png"
                     
                ></p>
<h4 id="Population-Count"><a href="#Population-Count" class="headerlink" title="Population Count"></a>Population Count</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_62.png"
                     
                ></p>
<ul>
<li>留意清除最低位的 1 的使用</li>
<li>数字小的时候才好用</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_63.png"
                     
                ></p>
<ul>
<li>内存操作的成本是性能的主要瓶颈</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_64.png"
                     
                ></p>
<ul>
<li>这里加法是真加法 不是或</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_65.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_66.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mit-6-172-3/Lecture-3-Bit-Hacks_67.png"
                     
                ></p>
<ul>
<li>popcount 指令比自己编码快很多</li>
</ul>
<h1 id="英语词汇笔记"><a href="#英语词汇笔记" class="headerlink" title="英语词汇笔记"></a>英语词汇笔记</h1><table>
<thead>
<tr>
<th>单词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>binary</td>
<td>二进制</td>
</tr>
<tr>
<td>prefix</td>
<td>前置</td>
</tr>
<tr>
<td>toggle</td>
<td>切换</td>
</tr>
<tr>
<td>prefetching</td>
<td>预取</td>
</tr>
<tr>
<td>Modular</td>
<td>模</td>
</tr>
<tr>
<td>boundary case</td>
<td>边界条件</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Performance Engineering Of Software Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>HW2 Profiling Serial MergeSort</title>
    <url>/2023/02/15/mit-6-172-hw2/</url>
    <content><![CDATA[<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><ul>
<li>作业介绍<ul>
<li>recitation-测试</li>
<li>homework-改进代码</li>
</ul>
</li>
<li>提前设置<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &lt;target&gt; DEBUG=1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="Recitation-Perf-and-Cachegrind"><a href="#Recitation-Perf-and-Cachegrind" class="headerlink" title="Recitation: Perf and Cachegrind"></a>Recitation: Perf and Cachegrind</h1><h2 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h2><h3 id="安装-Perf"><a href="#安装-Perf" class="headerlink" title="安装 Perf"></a>安装 Perf</h3><p>出现了问题，已解决，但是没有记录</p>
<h3 id="Perf-个人使用速查"><a href="#Perf-个人使用速查" class="headerlink" title="Perf 个人使用速查"></a>Perf 个人使用速查</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf record</span><br><span class="line">用法：</span><br><span class="line">$ perf record &lt;program_name&gt; &lt;program_arguments&gt;</span><br></pre></td></tr></table></figure></div>

<p>running .&#x2F;isort n k will sort an array of n elements k times.</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo perf record ./isort 10000 10</span><br><span class="line">Sorting 10000 values...</span><br><span class="line">Done!</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.035 MB perf.data (887 samples) ]</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf report</span><br><span class="line">用法：直接perf report</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo perf report</span><br><span class="line"># To display the perf.data header info, please use --header/--header-only options.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Total Lost Samples: 0</span><br><span class="line">#</span><br><span class="line"># Samples: 887  of event &#x27;cpu-clock:pppH&#x27;</span><br><span class="line"># Event count (approx.): 221750000</span><br><span class="line">#</span><br><span class="line"># Overhead  Command  Shared Object      Symbol</span><br><span class="line"># ........  .......  .................  .................</span><br><span class="line">#</span><br><span class="line">    99.44%  isort    isort              [.] isort</span><br><span class="line">     0.23%  isort    libc-2.27.so       [.] rand_r</span><br><span class="line">     0.11%  isort    [kernel.kallsyms]  [k] queue_work_on</span><br><span class="line">     0.11%  isort    [kernel.kallsyms]  [k] release_pages</span><br><span class="line">     0.11%  isort    isort              [.] main</span><br></pre></td></tr></table></figure></div>

<p>这里就可以看到 isort 占据了很大一部分时间</p>
<h2 id="Cachegrind"><a href="#Cachegrind" class="headerlink" title="Cachegrind"></a>Cachegrind</h2><p>Cachegrind (a Valgrind tool) is a cache and branch-prediction profiler<br>On virtual environments like those on AWS, hardware events providing information about branches and cache misses are often unavailable, so perf may not be helpful.</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">valgrind</span><br><span class="line">使用：</span><br><span class="line">$ valgrind --tool=cachegrind --branch-sim=yes &lt;program_name&gt; &lt;program_arguments&gt;</span><br><span class="line">输出解释：</span><br><span class="line">D1 represents the lowest-level cache (L1)</span><br><span class="line">LL represents the last (highest) level data cache (on most machines, L3)</span><br></pre></td></tr></table></figure></div>

<p>例子代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 MIT License by 6.172 Staff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> U = <span class="number">10000000</span>;   <span class="comment">// size of the array. 10 million vals ~= 40MB</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000000</span>;  <span class="comment">// number of searches to perform</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">data_t</span>* data = (<span class="type">data_t</span>*) <span class="built_in">malloc</span>(U * <span class="keyword">sizeof</span>(<span class="type">data_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error: not enough memory\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fill up the array with sequential (sorted) values.</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; U; i++) &#123;</span><br><span class="line">    data[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocated array of size %d\n&quot;</span>, U);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Summing %d random values...\n&quot;</span>, N);</span><br><span class="line"></span><br><span class="line">  <span class="type">data_t</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="type">data_t</span> seed = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="type">int</span> l = rand_r(&amp;seed) % U;</span><br><span class="line">    val = (val + data[l]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(data);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Done. Value = %d\n&quot;</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make sum</span><br></pre></td></tr></table></figure></div>

<p>剖析</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ valgrind --tool=cachegrind --branch-sim=yes ./sum</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">==125== Cachegrind, a cache and branch-prediction profiler</span><br><span class="line">==125== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Nicholas Nethercote et al.</span><br><span class="line">==125== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==125== Command: ./sum</span><br><span class="line">==125==</span><br><span class="line">--125-- warning: L3 cache found, using its data for the LL simulation.</span><br><span class="line">Allocated array of size 10000000</span><br><span class="line">Summing 100000000 random values...</span><br><span class="line">Done. Value = 938895920</span><br><span class="line">==125==</span><br><span class="line">==125== I   refs:      3,440,227,630</span><br><span class="line">==125== I1  misses:            1,195</span><br><span class="line">==125== LLi misses:            1,180</span><br><span class="line">==125== I1  miss rate:          0.00%</span><br><span class="line">==125== LLi miss rate:          0.00%</span><br><span class="line">==125==</span><br><span class="line">==125== D   refs:        610,074,405  (400,058,343 rd   + 210,016,062 wr)</span><br><span class="line">==125== D1  misses:      100,507,416  ( 99,881,550 rd   +     625,866 wr)</span><br><span class="line">==125== LLd misses:       37,859,997  ( 37,234,195 rd   +     625,802 wr)</span><br><span class="line">==125== D1  miss rate:          16.5% (       25.0%     +         0.3%  )</span><br><span class="line">==125== LLd miss rate:           6.2% (        9.3%     +         0.3%  )</span><br><span class="line">==125==</span><br><span class="line">==125== LL refs:         100,508,611  ( 99,882,745 rd   +     625,866 wr)</span><br><span class="line">==125== LL misses:        37,861,177  ( 37,235,375 rd   +     625,802 wr)</span><br><span class="line">==125== LL miss rate:            0.9% (        1.0%     +         0.3%  )</span><br><span class="line">==125==</span><br><span class="line">==125== Branches:        210,043,840  (110,043,336 cond + 100,000,504 ind)</span><br><span class="line">==125== Mispredicts:           5,456  (      5,248 cond +         208 ind)</span><br><span class="line">==125== Mispred rate:            0.0% (        0.0%     +         0.0%   )</span><br></pre></td></tr></table></figure></div>

<p>查找 Cache 信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lscpu</span><br><span class="line">用法：</span><br><span class="line">$ lscpu</span><br><span class="line">作用：</span><br><span class="line">find information about your CPU and its caches</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:        x86_64</span><br><span class="line">CPU op-mode(s):      32-bit, 64-bit</span><br><span class="line">Byte Order:          Little Endian</span><br><span class="line">CPU(s):              20</span><br><span class="line">On-line CPU(s) list: 0-19</span><br><span class="line">Thread(s) per core:  2</span><br><span class="line">Core(s) per socket:  10</span><br><span class="line">Socket(s):           1</span><br><span class="line">Vendor ID:           GenuineIntel</span><br><span class="line">CPU family:          6</span><br><span class="line">Model:               154</span><br><span class="line">Model name:          12th Gen Intel(R) Core(TM) i7-12700H</span><br><span class="line">Stepping:            3</span><br><span class="line">CPU MHz:             2687.998</span><br><span class="line">BogoMIPS:            5375.99</span><br><span class="line">Virtualization:      VT-x</span><br><span class="line">Hypervisor vendor:   Microsoft</span><br><span class="line">Virtualization type: full</span><br><span class="line">L1d cache:           48K</span><br><span class="line">L1i cache:           32K</span><br><span class="line">L2 cache:            1280K</span><br><span class="line">L3 cache:            24576K</span><br><span class="line">Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves umip waitpkg gfni vaes vpclmulqdq rdpid movdiri movdir64b fsrm serialize flush_l1d arch_capabilities</span><br></pre></td></tr></table></figure></div>

<p>在我们这里就可以看到 L1、L2 和 L3 的 Cache 信息了</p>
<p>再观察输出结果，因为我们写 Cache miss 少（代码顺序写）和读 Cache miss 多（代码随机读）<br>然后我们通过改变 U 和 N，控制 U 小于 L1、L2、L3 Cache 等情况，就能看出 N、U 大小和 D、L、LLD Cache miss 的关系</p>
<h1 id="Homework-Sorting"><a href="#Homework-Sorting" class="headerlink" title="Homework: Sorting"></a>Homework: Sorting</h1><h3 id="Write-up-1"><a href="#Write-up-1" class="headerlink" title="Write-up 1:"></a>Write-up 1:</h3><blockquote>
<p>Compare the <strong>Cachegrind</strong> output on the DEBUG&#x3D;1 code versus DEBUG&#x3D;0 compiler optimized code. Explain the advantages and disadvantages of using instruction count as a substitute for time when you compare the performance of different versions of this program</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang main.c tests.c util.c isort.c sort_a.c sort_c.c sort_i.c sort_p.c sort_m.c sort_f.c -O3 -DNDEBUG -g -Wall -std=gnu99 -gdwarf-3 -always-inline -lrt -lm  -o sort</span><br><span class="line">clang: warning: argument unused during compilation: &#x27;-always-inline&#x27; [-Wunused-command-line-argument]</span><br><span class="line"></span><br><span class="line">$ valgrind --tool=cachegrind --branch-sim=yes ./sort 10000 10</span><br><span class="line">==184== Cachegrind, a cache and branch-prediction profiler</span><br><span class="line">==184== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Nicholas Nethercote et al.</span><br><span class="line">==184== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==184== Command: ./sort 10000 10</span><br><span class="line">==184==</span><br><span class="line">--184-- warning: L3 cache found, using its data for the LL simulation.</span><br><span class="line"></span><br><span class="line">Running test #0...</span><br><span class="line">Generating random array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.014364 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.013956 sec</span><br><span class="line">Generating inverted array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.027513 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.027134 sec</span><br><span class="line"></span><br><span class="line">Running test #1...</span><br><span class="line"> --&gt; test_zero_element at line 245: PASS</span><br><span class="line"></span><br><span class="line">Running test #2...</span><br><span class="line"> --&gt; test_one_element at line 266: PASS</span><br><span class="line">Done testing.</span><br><span class="line">==184==</span><br><span class="line">==184== I   refs:      235,925,874</span><br><span class="line">==184== I1  misses:          1,586</span><br><span class="line">==184== LLi misses:          1,467</span><br><span class="line">==184== I1  miss rate:        0.00%</span><br><span class="line">==184== LLi miss rate:        0.00%</span><br><span class="line">==184==</span><br><span class="line">==184== D   refs:       87,546,459  (52,667,725 rd   + 34,878,734 wr)</span><br><span class="line">==184== D1  misses:        228,442  (   127,084 rd   +    101,358 wr)</span><br><span class="line">==184== LLd misses:          5,123  (     2,420 rd   +      2,703 wr)</span><br><span class="line">==184== D1  miss rate:         0.3% (       0.2%     +        0.3%  )</span><br><span class="line">==184== LLd miss rate:         0.0% (       0.0%     +        0.0%  )</span><br><span class="line">==184==</span><br><span class="line">==184== LL refs:           230,028  (   128,670 rd   +    101,358 wr)</span><br><span class="line">==184== LL misses:           6,590  (     3,887 rd   +      2,703 wr)</span><br><span class="line">==184== LL miss rate:          0.0% (       0.0%     +        0.0%  )</span><br><span class="line">==184==</span><br><span class="line">==184== Branches:       40,474,926  (38,773,975 cond +  1,700,951 ind)</span><br><span class="line">==184== Mispredicts:     2,484,878  ( 2,484,522 cond +        356 ind)</span><br><span class="line">==184== Mispred rate:          6.1% (       6.4%     +        0.0%   )</span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">rm -f ./sort *.std* *.gcov *.gcda *.gcno default.profraw</span><br><span class="line"></span><br><span class="line">$ make DEBUG=1</span><br><span class="line">clang main.c tests.c util.c isort.c sort_a.c sort_c.c sort_i.c sort_p.c sort_m.c sort_f.c -DDEBUG -O0 -g -Wall -std=gnu99 -gdwarf-3 -always-inline -lrt -lm  -o sort</span><br><span class="line">clang: warning: argument unused during compilation: &#x27;-always-inline&#x27; [-Wunused-command-line-argument]</span><br><span class="line"></span><br><span class="line">$  valgrind --tool=cachegrind --</span><br><span class="line">ranch-sim=yes ./sort 10000 10valgrind: no program specified</span><br><span class="line">valgrind: Use --help for more information.</span><br><span class="line">cjl@ChenJulian:~/solution/mit6.172/Homework/HW2/homework$  valgrind --tool=cachegrind --branch-sim=yes ./sort 10000 10</span><br><span class="line">==206== Cachegrind, a cache and branch-prediction profiler</span><br><span class="line">==206== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Nicholas Nethercote et al.</span><br><span class="line">==206== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==206== Command: ./sort 10000 10</span><br><span class="line">==206==</span><br><span class="line">--206-- warning: L3 cache found, using its data for the LL simulation.</span><br><span class="line"></span><br><span class="line">Running test #0...</span><br><span class="line">Generating random array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.025243 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.025381 sec</span><br><span class="line">Generating inverted array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.049681 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.049848 sec</span><br><span class="line"></span><br><span class="line">Running test #1...</span><br><span class="line"> --&gt; test_zero_element at line 245: PASS</span><br><span class="line"></span><br><span class="line">Running test #2...</span><br><span class="line"> --&gt; test_one_element at line 266: PASS</span><br><span class="line">Done testing.</span><br><span class="line">==206==</span><br><span class="line">==206== I   refs:      408,412,706</span><br><span class="line">==206== I1  misses:          1,553</span><br><span class="line">==206== LLi misses:          1,457</span><br><span class="line">==206== I1  miss rate:        0.00%</span><br><span class="line">==206== LLi miss rate:        0.00%</span><br><span class="line">==206==</span><br><span class="line">==206== D   refs:      260,697,695  (194,384,270 rd   + 66,313,425 wr)</span><br><span class="line">==206== D1  misses:        228,025  (    126,767 rd   +    101,258 wr)</span><br><span class="line">==206== LLd misses:          5,115  (      2,411 rd   +      2,704 wr)</span><br><span class="line">==206== D1  miss rate:         0.1% (        0.1%     +        0.2%  )</span><br><span class="line">==206== LLd miss rate:         0.0% (        0.0%     +        0.0%  )</span><br><span class="line">==206==</span><br><span class="line">==206== LL refs:           229,578  (    128,320 rd   +    101,258 wr)</span><br><span class="line">==206== LL misses:           6,572  (      3,868 rd   +      2,704 wr)</span><br><span class="line">==206== LL miss rate:          0.0% (        0.0%     +        0.0%  )</span><br><span class="line">==206==</span><br><span class="line">==206== Branches:       45,174,708  ( 43,473,813 cond +  1,700,895 ind)</span><br><span class="line">==206== Mispredicts:     3,109,490  (  3,109,160 cond +        330 ind)</span><br><span class="line">==206== Mispred rate:          6.9% (        7.2%     +        0.0%   )</span><br></pre></td></tr></table></figure></div>

<p>得出结果</p>
<table>
<thead>
<tr>
<th>DEBUG</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>指令数</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>Cache Misses 率</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>MISpredicts 率</td>
<td>小</td>
<td>大</td>
</tr>
</tbody></table>
<p>O0 牺牲了 cache 命中率，但是指令数少，时间快</p>
<h2 id="inlining"><a href="#inlining" class="headerlink" title="inlining"></a>inlining</h2><blockquote>
<p>You would like to see how much inline functions can help. Copy over the code from sort_a.c into sort_i.c, and change all the routine names from <function>_a to <function>_i. Using the inline keyword, inline one or more of the functions in sort_i.c and util.c. To add the sort_i routine to the testing suite, uncomment the line in main.c, under testFunc, that specifies sort_i. Profile and annotate the inlined program.</p>
</blockquote>
<h3 id="Write-up-2"><a href="#Write-up-2" class="headerlink" title="Write-up 2:"></a>Write-up 2:</h3><blockquote>
<p>Explain which functions you chose to inline and report the performance differences you observed between the inlined and uninlined sorting routines.</p>
</blockquote>
<p>如题，将 sort_i 中的 merge_i 和 copy_i 设置为 inline。并进行测试</p>
<p>编译和 perf record 的过程不再给出</p>
<ul>
<li>no use inlining &amp; DEBUG&#x3D;1</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">cjl@ChenJulian:/mnt/c/Data Files/mit6<span class="number">.172</span>/Homework/HW2/homework$ perf record ./sort <span class="number">10000</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Running test #<span class="number">0.</span>..</span><br><span class="line">Generating random <span class="built_in">array</span> of <span class="number">10000</span> elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line <span class="number">217</span>: PASS</span><br><span class="line">sort_a          : Elapsed execution time: <span class="number">0.000694</span> sec</span><br><span class="line">sort_a repeated : Elapsed execution time: <span class="number">0.000679</span> sec</span><br><span class="line">sort_i          : Elapsed execution time: <span class="number">0.000679</span> sec</span><br><span class="line">Generating inverted <span class="built_in">array</span> of <span class="number">10000</span> elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line <span class="number">217</span>: PASS</span><br><span class="line">sort_a          : Elapsed execution time: <span class="number">0.000950</span> sec</span><br><span class="line">sort_a repeated : Elapsed execution time: <span class="number">0.000989</span> sec</span><br><span class="line">sort_i          : Elapsed execution time: <span class="number">0.000942</span> sec</span><br><span class="line"></span><br><span class="line">Running test #<span class="number">1.</span>..</span><br><span class="line"> --&gt; test_zero_element at line <span class="number">245</span>: PASS</span><br><span class="line"></span><br><span class="line">Running test #<span class="number">2.</span>..</span><br><span class="line"> --&gt; test_one_element at line <span class="number">266</span>: PASS</span><br><span class="line">Done testing.</span><br><span class="line">[ perf record: Woken up <span class="number">1</span> times to write data ]</span><br><span class="line">[ perf record: Captured and wrote <span class="number">0.006</span> MB perf.data (<span class="number">116</span> samples) ]</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cjl@ChenJulian:/mnt/c/Data Files/mit6.172/Homework/HW2/homework$ perf report</span><br><span class="line"># To display the perf.data header info, please use --header/--header-only options.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Total Lost Samples: 0</span><br><span class="line">#</span><br><span class="line"># Samples: 116  of event &#x27;cpu-clock:uhpppH&#x27;</span><br><span class="line"># Event count (approx.): 29000000</span><br><span class="line">#</span><br><span class="line"># Overhead  Command  Shared Object  Symbol</span><br><span class="line"># ........  .......  .............  ...........................</span><br><span class="line">#</span><br><span class="line">    43.10%  sort     sort           [.] sort_a</span><br><span class="line">    17.24%  sort     libc-2.27.so   [.] cfree@GLIBC_2.2.5</span><br><span class="line">    16.38%  sort     libc-2.27.so   [.] malloc</span><br><span class="line">    15.52%  sort     sort           [.] sort_i</span><br><span class="line">     2.59%  sort     sort           [.] mem_alloc</span><br><span class="line">     1.72%  sort     sort           [.] mem_free</span><br><span class="line">     0.86%  sort     libc-2.27.so   [.] intel_check_word.isra.0</span><br><span class="line">     0.86%  sort     libc-2.27.so   [.] rand_r</span><br><span class="line">     0.86%  sort     sort           [.] free@plt</span><br><span class="line">     0.86%  sort     sort           [.] malloc@plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># (Tip: Show current config key-value pairs: perf config --list)</span><br><span class="line">#</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cjl@ChenJulian:/mnt/c/Data Files/mit6.172/Homework/HW2/homework$ valgrind --tool=cachegrind --branch-sim=yes ./sort 10000 10</span><br><span class="line">==698== Cachegrind, a cache and branch-prediction profiler</span><br><span class="line">==698== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Nicholas Nethercote et al.</span><br><span class="line">==698== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==698== Command: ./sort 10000 10</span><br><span class="line">==698==</span><br><span class="line">--698-- warning: L3 cache found, using its data for the LL simulation.</span><br><span class="line"></span><br><span class="line">Running test #0...</span><br><span class="line">Generating random array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.014621 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.014605 sec</span><br><span class="line">sort_i          : Elapsed execution time: 0.014851 sec</span><br><span class="line">Generating inverted array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.028227 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.028304 sec</span><br><span class="line">sort_i          : Elapsed execution time: 0.028753 sec</span><br><span class="line"></span><br><span class="line">Running test #1...</span><br><span class="line"> --&gt; test_zero_element at line 245: PASS</span><br><span class="line"></span><br><span class="line">Running test #2...</span><br><span class="line"> --&gt; test_one_element at line 266: PASS</span><br><span class="line">Done testing.</span><br><span class="line">==698==</span><br><span class="line">==698== I   refs:      351,917,014</span><br><span class="line">==698== I1  misses:          1,624</span><br><span class="line">==698== LLi misses:          1,494</span><br><span class="line">==698== I1  miss rate:        0.00%</span><br><span class="line">==698== LLi miss rate:        0.00%</span><br><span class="line">==698==</span><br><span class="line">==698== D   refs:      130,160,086  (78,415,144 rd   + 51,744,942 wr)</span><br><span class="line">==698== D1  misses:        324,704  (   184,171 rd   +    140,533 wr)</span><br><span class="line">==698== LLd misses:          5,123  (     2,421 rd   +      2,702 wr)</span><br><span class="line">==698== D1  miss rate:         0.2% (       0.2%     +        0.3%  )</span><br><span class="line">==698== LLd miss rate:         0.0% (       0.0%     +        0.0%  )</span><br><span class="line">==698==</span><br><span class="line">==698== LL refs:           326,328  (   185,795 rd   +    140,533 wr)</span><br><span class="line">==698== LL misses:           6,617  (     3,915 rd   +      2,702 wr)</span><br><span class="line">==698== LL miss rate:          0.0% (       0.0%     +        0.0%  )</span><br><span class="line">==698==</span><br><span class="line">==698== Branches:       60,182,795  (57,681,766 cond +  2,501,029 ind)</span><br><span class="line">==698== Mispredicts:     3,703,747  ( 3,703,346 cond +        401 ind)</span><br><span class="line">==698== Mispred rate:          6.2% (       6.4%     +        0.0%   )</span><br></pre></td></tr></table></figure></div>

<ul>
<li>use inlining &amp; DEBUG&#x3D;1</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">$ cjl@ChenJulian:/mnt/c/Data Files/mit6<span class="number">.172</span>/Homework/HW2/homework$ perf record ./sort <span class="number">10000</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Running test #<span class="number">0.</span>..</span><br><span class="line">Generating random <span class="built_in">array</span> of <span class="number">10000</span> elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line <span class="number">217</span>: PASS</span><br><span class="line">sort_a          : Elapsed execution time: <span class="number">0.001043</span> sec</span><br><span class="line">sort_a repeated : Elapsed execution time: <span class="number">0.001049</span> sec</span><br><span class="line">sort_i          : Elapsed execution time: <span class="number">0.001048</span> sec</span><br><span class="line">Generating inverted <span class="built_in">array</span> of <span class="number">10000</span> elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line <span class="number">217</span>: PASS</span><br><span class="line">sort_a          : Elapsed execution time: <span class="number">0.001652</span> sec</span><br><span class="line">sort_a repeated : Elapsed execution time: <span class="number">0.001609</span> sec</span><br><span class="line">sort_i          : Elapsed execution time: <span class="number">0.001595</span> sec</span><br><span class="line"></span><br><span class="line">Running test #<span class="number">1.</span>..</span><br><span class="line"> --&gt; test_zero_element at line <span class="number">245</span>: PASS</span><br><span class="line"></span><br><span class="line">Running test #<span class="number">2.</span>..</span><br><span class="line"> --&gt; test_one_element at line <span class="number">266</span>: PASS</span><br><span class="line">Done testing.</span><br><span class="line">[ perf record: Woken up <span class="number">1</span> times to write data ]</span><br><span class="line">[ perf record: Captured and wrote <span class="number">0.009</span> MB perf.data (<span class="number">203</span> samples) ]</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cjl@ChenJulian:/mnt/c/Data Files/mit6.172/Homework/HW2/homework$ perf report</span><br><span class="line"># To display the perf.data header info, please use --header/--header-only options.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Total Lost Samples: 0</span><br><span class="line">#</span><br><span class="line"># Samples: 203  of event &#x27;cpu-clock:uhpppH&#x27;</span><br><span class="line"># Event count (approx.): 50750000</span><br><span class="line">#</span><br><span class="line"># Overhead  Command  Shared Object  Symbol</span><br><span class="line"># ........  .......  .............  ................................</span><br><span class="line">#</span><br><span class="line">    34.98%  sort     sort           [.] merge_a</span><br><span class="line">    15.27%  sort     sort           [.] merge_i</span><br><span class="line">    12.32%  sort     sort           [.] copy_a</span><br><span class="line">     9.85%  sort     libc-2.27.so   [.] cfree@GLIBC_2.2.5</span><br><span class="line">     8.87%  sort     sort           [.] copy_i</span><br><span class="line">     5.42%  sort     sort           [.] sort_a</span><br><span class="line">     3.45%  sort     libc-2.27.so   [.] malloc</span><br><span class="line">     1.97%  sort     sort           [.] copy_data</span><br><span class="line">     1.97%  sort     sort           [.] mem_alloc</span><br><span class="line">     1.97%  sort     sort           [.] sort_i</span><br><span class="line">     0.99%  sort     sort           [.] init_data</span><br><span class="line">     0.99%  sort     sort           [.] mem_free</span><br><span class="line">     0.49%  sort     ld-2.27.so     [.] strcmp</span><br><span class="line">     0.49%  sort     libc-2.27.so   [.] __fxstat64</span><br><span class="line">     0.49%  sort     libc-2.27.so   [.] __memmove_avx_unaligned_erms</span><br><span class="line">     0.49%  sort     sort           [.] malloc@plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># (Tip: Customize output of perf script with: perf script -F event,ip,sym)</span><br><span class="line">#</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cjl@ChenJulian:/mnt/c/Data Files/mit6.172/Homework/HW2/homework$ valgrind --tool=cachegrind --branch-sim=yes ./sort 10000 10</span><br><span class="line">==758== Cachegrind, a cache and branch-prediction profiler</span><br><span class="line">==758== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Nicholas Nethercote et al.</span><br><span class="line">==758== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==758== Command: ./sort 10000 10</span><br><span class="line">==758==</span><br><span class="line">--758-- warning: L3 cache found, using its data for the LL simulation.</span><br><span class="line"></span><br><span class="line">Running test #0...</span><br><span class="line">Generating random array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.025676 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.025433 sec</span><br><span class="line">sort_i          : Elapsed execution time: 0.025869 sec</span><br><span class="line">Generating inverted array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_a          : Elapsed execution time: 0.050344 sec</span><br><span class="line">sort_a repeated : Elapsed execution time: 0.050162 sec</span><br><span class="line">sort_i          : Elapsed execution time: 0.050949 sec</span><br><span class="line"></span><br><span class="line">Running test #1...</span><br><span class="line"> --&gt; test_zero_element at line 245: PASS</span><br><span class="line"></span><br><span class="line">Running test #2...</span><br><span class="line"> --&gt; test_one_element at line 266: PASS</span><br><span class="line">Done testing.</span><br><span class="line">==758==</span><br><span class="line">==758== I   refs:      608,332,662</span><br><span class="line">==758== I1  misses:          1,574</span><br><span class="line">==758== LLi misses:          1,481</span><br><span class="line">==758== I1  miss rate:        0.00%</span><br><span class="line">==758== LLi miss rate:        0.00%</span><br><span class="line">==758==</span><br><span class="line">==758== D   refs:      388,800,501  (289,890,848 rd   + 98,909,653 wr)</span><br><span class="line">==758== D1  misses:        323,971  (    183,785 rd   +    140,186 wr)</span><br><span class="line">==758== LLd misses:          5,122  (      2,419 rd   +      2,703 wr)</span><br><span class="line">==758== D1  miss rate:         0.1% (        0.1%     +        0.1%  )</span><br><span class="line">==758== LLd miss rate:         0.0% (        0.0%     +        0.0%  )</span><br><span class="line">==758==</span><br><span class="line">==758== LL refs:           325,545  (    185,359 rd   +    140,186 wr)</span><br><span class="line">==758== LL misses:           6,603  (      3,900 rd   +      2,703 wr)</span><br><span class="line">==758== LL miss rate:          0.0% (        0.0%     +        0.0%  )</span><br><span class="line">==758==</span><br><span class="line">==758== Branches:       67,436,323  ( 64,935,328 cond +  2,500,995 ind)</span><br><span class="line">==758== Mispredicts:     4,682,231  (  4,681,844 cond +        387 ind)</span><br><span class="line">==758== Mispred rate:          6.9% (        7.2%     +        0.0%   )</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到内联函数会导致时间花费更长。</p>
<p>在这个写作任务中，你需要解释递归函数内联化可能导致的性能下降，并说明使用 Cachegrind 收集的分析数据如何帮助你测量这些负面性能影响。</p>
<p>递归函数内联化的潜在性能问题包括：</p>
<ol>
<li><strong>代码膨胀</strong>：内联递归函数会导致代码膨胀，因为每次递归调用都会展开为相应的代码，这可能会导致生成更多的指令。代码膨胀可能会增加指令缓存的压力，降低缓存命中率。</li>
<li><strong>栈消耗</strong>：递归函数通常使用函数调用栈来保存每个递归调用的状态。内联递归函数可能会导致栈消耗过大，尤其在递归深度较大时。较大的栈消耗可能会导致栈溢出或者减慢程序的执行速度。</li>
<li><strong>冗余计算</strong>：内联展开递归函数的过程中，可能会进行一些冗余计算，因为相同的计算可能在不同的展开代码中多次出现。这会增加指令执行的开销，降低程序的效率。</li>
</ol>
<h2 id="Pointers-vs-Arrays"><a href="#Pointers-vs-Arrays" class="headerlink" title="Pointers vs Arrays"></a>Pointers vs Arrays</h2><h3 id="Write-up-4"><a href="#Write-up-4" class="headerlink" title="Write-up 4"></a>Write-up 4</h3><blockquote>
<p>​ Give a reason why using pointers may improve performance. Report on any performance differences you observed in your implementation.</p>
</blockquote>
<p>指针</p>
<h2 id="Coarsening"><a href="#Coarsening" class="headerlink" title="Coarsening"></a>Coarsening</h2><h3 id="Write-up-5"><a href="#Write-up-5" class="headerlink" title="Write-up 5"></a>Write-up 5</h3><blockquote>
<p>​ Explain what sorting algorithm you used and how you chose the number of elements to be sorted in the base case. Report on the performance differences you observed.</p>
</blockquote>
<ul>
<li>未优化</li>
</ul>
<p>代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void merge_m(data_t *A, int p, int q, int r)</span><br><span class="line">&#123;</span><br><span class="line">  assert(A);</span><br><span class="line">  assert(p &lt;= q);</span><br><span class="line">  assert((q + 1) &lt;= r);</span><br><span class="line">  int n1 = q - p + 1;</span><br><span class="line">  int n2 = r - q;</span><br><span class="line"></span><br><span class="line">  data_t *left = 0, *right = 0;</span><br><span class="line">  mem_alloc(&amp;left, n1 + 1);</span><br><span class="line">  mem_alloc(&amp;right, n2 + 1);</span><br><span class="line">  if (left == NULL || right == NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    mem_free(&amp;left);</span><br><span class="line">    mem_free(&amp;right);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  copy_m(&amp;(A[p]), left, n1);</span><br><span class="line">  copy_m(&amp;(A[q + 1]), right, n2);</span><br><span class="line">  left[n1] = UINT_MAX;</span><br><span class="line">  right[n2] = UINT_MAX;</span><br><span class="line"></span><br><span class="line">  int i = 0;</span><br><span class="line">  int j = 0;</span><br><span class="line"></span><br><span class="line">  for (int k = p; k &lt;= r; k++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (left[i] &lt;= right[j])</span><br><span class="line">    &#123;</span><br><span class="line">      A[k] = left[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      A[k] = right[j];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mem_free(&amp;left);</span><br><span class="line">  mem_free(&amp;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cjl@ChenJulian:/mnt/c/Data Files/mit6.172/Homework/HW2/homework$ valgrind --tool=cachegrind --branch-sim=yes ./sort 10000 10</span><br><span class="line">==41== Cachegrind, a cache and branch-prediction profiler</span><br><span class="line">==41== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Nicholas Nethercote et al.</span><br><span class="line">==41== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==41== Command: ./sort 10000 10</span><br><span class="line">==41==</span><br><span class="line">--41-- warning: L3 cache found, using its data for the LL simulation.</span><br><span class="line"></span><br><span class="line">Running test #0...</span><br><span class="line">Generating random array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_m          : Elapsed execution time: 0.031639 sec</span><br><span class="line">Generating inverted array of 10000 elements</span><br><span class="line">Arrays are sorted: yes</span><br><span class="line"> --&gt; test_correctness at line 217: PASS</span><br><span class="line">sort_m          : Elapsed execution time: 0.062058 sec</span><br><span class="line"></span><br><span class="line">Running test #1...</span><br><span class="line"> --&gt; test_zero_element at line 245: PASS</span><br><span class="line"></span><br><span class="line">Running test #2...</span><br><span class="line"> --&gt; test_one_element at line 266: PASS</span><br><span class="line">Done testing.</span><br><span class="line">==41==</span><br><span class="line">==41== I   refs:      208,493,318</span><br><span class="line">==41== I1  misses:          1,554</span><br><span class="line">==41== LLi misses:          1,458</span><br><span class="line">==41== I1  miss rate:        0.00%</span><br><span class="line">==41== LLi miss rate:        0.00%</span><br><span class="line">==41==</span><br><span class="line">==41== D   refs:      132,595,246  (98,877,918 rd   + 33,717,328 wr)</span><br><span class="line">==41== D1  misses:        131,781  (    69,494 rd   +     62,287 wr)</span><br><span class="line">==41== LLd misses:          5,116  (     2,413 rd   +      2,703 wr)</span><br><span class="line">==41== D1  miss rate:         0.1% (       0.1%     +        0.2%  )</span><br><span class="line">==41== LLd miss rate:         0.0% (       0.0%     +        0.0%  )</span><br><span class="line">==41==</span><br><span class="line">==41== LL refs:           133,335  (    71,048 rd   +     62,287 wr)</span><br><span class="line">==41== LL misses:           6,574  (     3,871 rd   +      2,703 wr)</span><br><span class="line">==41== LL miss rate:          0.0% (       0.0%     +        0.0%  )</span><br><span class="line">==41==</span><br><span class="line">==41== Branches:       22,912,991  (22,012,175 cond +    900,816 ind)</span><br><span class="line">==41== Mispredicts:     1,558,061  ( 1,557,736 cond +        325 ind)</span><br><span class="line">==41== Mispred rate:          6.8% (       7.1%     +        0.0%   )</span><br></pre></td></tr></table></figure></div>

<ul>
<li>优化后：</li>
</ul>
<p>报错,感觉有点花费时间。先不细究了。</p>
]]></content>
      <tags>
        <tag>Performance Engineering Of Software Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenMp优化方法</title>
    <url>/2023/07/03/openmp/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><p>设置<strong>要使用</strong>的<strong>线程数</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">omp_set_num_threads</span><span class="params">(<span class="type">int</span> num_threads)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取<strong>当前线程数</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">omp_get_num_threads</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取当前线程的<strong>编号</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">omp_get_thread_num</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取<strong>可以使用</strong>的<strong>最大线程数</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">omp_get_max_threads</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取系统中的<strong>处理器核心数</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">omp_get_num_procs</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取<strong>当前时间</strong>（以秒为单位），用于计算代码执行时间</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">omp_get_wtime</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建并行区域，其中包含并行执行的代码块</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 并行执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指示<strong>一个</strong>for 循环可以被并行执行</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 并行执行的循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指示代码块被划分为多个独立的部分，并行执行各个部分</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第二部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更多部分...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将<strong>一个</strong>for 循环并行化，使多个线程并行执行迭代</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 并行执行的循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建一个<strong>临界区</strong>，在其中只允许一个线程同时执行</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对共享变量执行原子操作，确保操作的原子性</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp atomic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 原子操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对共享变量执行归约操作，例如求和、求积等</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp reduction(operator: variable)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用指定数量的线程并行</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(nthreads)</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<ul>
<li><p>指定循环迭代的调度方式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma omp for schedule(kind,chunk_size)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>kind：static, dynamic, guided<ul>
<li>静态调度（Static Schedule）：<ul>
<li><code>kind</code>参数为<code>static</code>时，采用静态调度方式。</li>
<li>静态调度将循环迭代均匀地划分为固定大小的迭代块，每个线程获取一个或多个连续的迭代块。</li>
<li><code>chunk_size</code>参数表示每个线程获取的连续迭代块的大小。</li>
</ul>
</li>
<li>动态调度（Dynamic Schedule）：<ul>
<li><code>kind</code>参数为<code>dynamic</code>时，采用动态调度方式。</li>
<li>动态调度将循环迭代均匀地划分为较小的迭代块，每个线程获取一个迭代块执行完毕后再获取下一个迭代块。</li>
<li><code>chunk_size</code>参数表示每个线程获取的迭代块的大小。</li>
</ul>
</li>
<li>导引式调度（Guided Schedule）：<ul>
<li><code>kind</code>参数为<code>guided</code>时，采用导引式调度方式。</li>
<li>导引式调度类似于动态调度，但初始的迭代块较大，逐渐减小。</li>
<li>初始迭代块的大小由系统设定，每个线程获取一个迭代块执行完毕后再获取下一个较小的迭代块。</li>
<li><code>chunk_size</code>参数可以用于指定最小的迭代块大小，如果没有指定，则使用系统设定的默认值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/1.png"
                      alt="2023-07-03-openmp"
                ></p>
<ul>
<li><p>并行循环结束后避免隐式的同步等待</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma omp parallel</span><br><span class="line">&#123;</span><br><span class="line">	#pragma omp for nowait</span><br><span class="line">	for (i=1; i&lt;n; i++)</span><br><span class="line">		b[i] = (a[i] + a[i-1]) / 2.0;</span><br><span class="line">	#pragma omp for nowait</span><br><span class="line">	for (i=0; i&lt;m; i++)</span><br><span class="line">		y[i] = sqrt(z[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>#pragma omp for</code>指令会在循环结束后进行隐式的同步等待，确保所有线程都完成了循环的执行。这会引入一定的同步开销。</p>
<p>注意，使用<code>nowait</code>指令需要确保循环之后没有任何依赖于循环结果的计算，否则可能会导致错误的结果。</p>
</li>
<li><p>将多个嵌套的并行循环合并为一个并行循环</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for collapse(2)private(i, k, j)</span></span><br><span class="line">	<span class="keyword">for</span> (k=kl; k&lt;=ku; k+=ks)</span><br><span class="line">        <span class="keyword">for</span> (j=jl; j&lt;=ju; j+=js)</span><br><span class="line">            <span class="keyword">for</span> (i=il; i&lt;=iu; i+=is)</span><br><span class="line">                bar(a,i,j,k);</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，<code>#pragma omp for</code>指令只会并行化最外层的循环，对于嵌套的循环不会进行并行化。</p>
<ul>
<li><code>#pragma omp for collapse(2)</code>：这是 OpenMP 的并行化指令，表示要并行化下面的嵌套循环。<code>collapse(2)</code>指定将两个嵌套循环（<code>j</code>和<code>i</code>）合并为一个循环，并进行并行化。</li>
<li><code>private(i, k, j)</code>：这是 OpenMP 的私有变量指令，指定了在并行执行中每个线程所使用的私有变量。在这个例子中，<code>i</code>、<code>k</code>、<code>j</code>被声明为私有变量，每个线程都有它们的私有副本，避免了数据竞争。</li>
</ul>
</li>
<li><p>在并行区域中的每个线程拥有自己的私有副本。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> is_private = <span class="number">-2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(is_private)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> rand_tid = rand();</span><br><span class="line">	is_private = rand_tid;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Thread ID %2d | is_private = %d\n&quot;</span>, omp_get_thread_num(), is_private); 		assert(is_private == rand_tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用<code>private</code>子句声明了变量<code>is_private</code>为私有变量。每个线程都有自己的<code>is_private</code>变量的副本，且初始值与线程的随机 ID 相同</p>
</li>
</ul>
<ul>
<li><p>创建并行任务。标记一段代码作为一个独立的任务，该任务可以由可用的线程池中的任何线程执行。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task priority(i) <span class="comment">//i越小优先级越高</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置依赖关系</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">depend</span><br><span class="line">in: 在开始前改该变量的修改要结束</span><br><span class="line">out：需要修改变量</span><br><span class="line">inout：两者兼之</span><br><span class="line">mutexinoutset：</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma omp parallel</span><br><span class="line">#pragma omp single</span><br><span class="line">&#123;</span><br><span class="line">#pragma omp task shared(x) depend(out: x)</span><br><span class="line">  x = 2;</span><br><span class="line">#pragma omp task shared(x) depend(in: x)</span><br><span class="line">  printf(&quot;x = %d\n&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历中使用并行</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">        <span class="keyword">do</span>(...);</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Only a single thread should execute this</span></span><br><span class="line">        <span class="keyword">do</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在函数中需要用’#pragma omp task’，在 main 函数中需要采用‘#pragma omp parallel‘和’#pragma omp single’</p>
</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li><p>设置线程数的用法</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(n_thread)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>等同于</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(n_thread)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>#pragma omp parallel for<code>和</code>#pragma omp for 有什么区别</p>
<p>#pragma omp parallel for<code>和</code>#pragma omp for 是 OpenMP 中用于并行化 for 循环的指令。它们的差别在于并行化的方式和默认行为。</p>
<p><code>#pragma omp for</code>指示编译器将其后面的 for 循环并行化执行。编译器根据线程数量自动划分迭代空间，每个线程负责执行一部分迭代。使用<code>#pragma omp for</code>时，需要确保循环的迭代之间不存在数据依赖关系或竞争条件。</p>
<p><code>#pragma omp parallel for</code>与<code>#pragma omp for</code>类似，也是用于并行化 for 循环。但是，<code>#pragma omp parallel for</code>更为灵活，允许更多的控制选项。使用<code>#pragma omp parallel for</code>时，可以设置循环迭代的调度方式（例如静态调度、动态调度等）、指定循环迭代的块大小等。</p>
<p>总结来说，<code>#pragma omp for</code>是一种简化的并行化 for 循环的方式，而<code>#pragma omp parallel for</code>则提供了更多的灵活性和控制选项。如果你只需要简单地并行化 for 循环，<code>#pragma omp for</code>足以满足需求。如果你需要更多的控制权或者对循环迭代的调度方式有特定要求，那么可以使用<code>#pragma omp parallel for</code>。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Parallel Computing</tag>
      </tags>
  </entry>
  <entry>
    <title>PV操作笔记</title>
    <url>/2023/06/01/pv/</url>
    <content><![CDATA[<h1 id="PV-操作介绍"><a href="#PV-操作介绍" class="headerlink" title="PV 操作介绍"></a>PV 操作介绍</h1><h2 id="P-signal"><a href="#P-signal" class="headerlink" title="P(signal)"></a>P(signal)</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(signal&lt;=<span class="number">0</span>);</span><br><span class="line">signal--;</span><br></pre></td></tr></table></figure></div>

<h2 id="V-signal"><a href="#V-signal" class="headerlink" title="V(signal)"></a>V(signal)</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">signal++;</span><br></pre></td></tr></table></figure></div>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>进入区（申请临界资源）-&gt; <strong>P</strong><br>临界区<br>退出区（释放临界资源）-&gt; <strong>V</strong></p>
<h1 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>有 n 个 <strong>箭头</strong> 设置 n 个 <strong>信号量</strong></li>
<li>从根节点开始</li>
<li>有 a 个 <strong>前驱节点</strong> 写 a 个 <strong>P</strong></li>
<li>有 b 个 <strong>后继节点</strong> 写 b 个 <strong>V</strong></li>
</ol>
<hr>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/pv/1.png"
                     
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,d=<span class="number">0</span>,e=o,f=<span class="number">0</span>,g=<span class="number">0</span>;</span><br><span class="line">begin</span><br><span class="line">    cobegin: <span class="comment">//并发</span></span><br><span class="line">        begin S1;</span><br><span class="line">            V(a);</span><br><span class="line">            V(b);</span><br><span class="line">        end</span><br><span class="line">        begin S2;</span><br><span class="line">            P(a);</span><br><span class="line">            V(d);</span><br><span class="line">            V(c);</span><br><span class="line">        end;</span><br><span class="line">        begin S3;</span><br><span class="line">            P(b);</span><br><span class="line">            V(e);</span><br><span class="line">        end</span><br><span class="line">        begin S4;</span><br><span class="line">            P(c);</span><br><span class="line">            V(f);</span><br><span class="line">        end;</span><br><span class="line">        begin S5;</span><br><span class="line">            P(d);</span><br><span class="line">            V(g);</span><br><span class="line">        end</span><br><span class="line">        begin S6;</span><br><span class="line">            P(e);</span><br><span class="line">            P(g);</span><br><span class="line">            P(f);</span><br><span class="line">        end;</span><br><span class="line">    coend</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="共享缓冲区"><a href="#共享缓冲区" class="headerlink" title="共享缓冲区"></a>共享缓冲区</h1><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ol>
<li><p>确定临界资源数量和互斥关系</p>
</li>
<li><p>互斥信号量初值为 1，资源信号量初值看题目要求</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex=<span class="number">1</span>,……；</span><br></pre></td></tr></table></figure></div></li>
<li><p>按照模板写出 main 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        进程<span class="number">1</span>(); 进程<span class="number">2</span>(); …… 进程n();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>写出进程要做的事情</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">进程n()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">        做什么</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>上下补充 PV 操作，<strong>先申请资源，再申请互斥。先释放互斥，再释放资源。</strong>(否则会死锁)</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">进程n()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        做什么</span><br><span class="line">        ……</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<h2 id="题目-1：互斥，缓冲区最多为-n"><a href="#题目-1：互斥，缓冲区最多为-n" class="headerlink" title="题目 1：互斥，缓冲区最多为 n"></a>题目 1：互斥，缓冲区最多为 n</h2><p>进程 reader 、 computer 共享缓冲区， reader 将资源给 computer 算，最多能放 n 个进缓冲区。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex=<span class="number">1</span>; <span class="comment">//缓冲区的互斥</span></span><br><span class="line">Semaphore empty=n,full=<span class="number">0</span>; <span class="comment">//资源</span></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(empty); <span class="comment">//先申资源</span></span><br><span class="line">        P(mutex); <span class="comment">//再申互斥</span></span><br><span class="line">        读数据放缓冲区</span><br><span class="line">        V(mutex); <span class="comment">//先释放互斥</span></span><br><span class="line">        V(full); <span class="comment">//再释放资源</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">computer()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        取数据计算</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        <span class="title function_">reader</span><span class="params">()</span>; computer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="题目-2-共享读，写互斥，读写互斥"><a href="#题目-2-共享读，写互斥，读写互斥" class="headerlink" title="题目 2 共享读，写互斥，读写互斥"></a>题目 2 共享读，写互斥，读写互斥</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore rmutex = <span class="number">1</span>, mutex = <span class="number">1</span>; <span class="comment">//读写互斥</span></span><br><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(rmutex);</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) P(mutex);</span><br><span class="line">        readCount ++;</span><br><span class="line">        V(rmutex);</span><br><span class="line"></span><br><span class="line">        读数据放缓冲区；</span><br><span class="line"></span><br><span class="line">        P(rmutex);</span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) V(mutex);</span><br><span class="line">        V(rmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        写数据进缓冲区；</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        <span class="title function_">reader</span><span class="params">()</span>; writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>共享读的实现：</strong> 比以前多个 readCount 和判断条件（注意多了 readCount 后每次改变 readCount 都要互斥）,读操作前后的互斥信号量有 if 条件（这里等于实现了读者优先）。<br><strong>读者优先的实现：</strong> 一旦有一个读者就拿走缓冲区互斥信号量 mutex ，从而不让写者进入缓冲区（注意和后文写者优先的区别，读者优先+共享读 的实现方式和 写者优先+互斥写 的实现方式不一样）</p>
<hr>
<h2 id="题目-3-共享读，读写公平，先来先服务"><a href="#题目-3-共享读，读写公平，先来先服务" class="headerlink" title="题目 3 共享读，读写公平，先来先服务"></a>题目 3 共享读，读写公平，先来先服务</h2><p><strong>第一版写错了</strong>，reader 的 V(S)应该放到读数据缓冲区操作前，不然就实现不了不共享读了，已修改。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore S = <span class="number">1</span>, rmutex = <span class="number">1</span>, mutex = <span class="number">1</span>; <span class="comment">//读写互斥</span></span><br><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(S);</span><br><span class="line"></span><br><span class="line">        P(rmutex);</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) P(mutex);</span><br><span class="line">        readCount ++;</span><br><span class="line">        V(rmutex);</span><br><span class="line"></span><br><span class="line">        V(S);</span><br><span class="line"></span><br><span class="line">        读数据放缓冲区；</span><br><span class="line"></span><br><span class="line">        P(rmutex);</span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) V(mutex);</span><br><span class="line">        V(rmutex);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(S);</span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        写数据进缓冲区；</span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        V(S);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        <span class="title function_">reader</span><span class="params">()</span>; writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>读写公平的实现：</strong> 在前后加 S 互斥信号量，重新回到公平情况。（跟题目 1 的差别是因为题目 1 不要求共享读）</p>
<hr>
<h2 id="题目-4-写优先，读写互斥，共享读"><a href="#题目-4-写优先，读写互斥，共享读" class="headerlink" title="题目 4 写优先，读写互斥，共享读"></a>题目 4 写优先，读写互斥，共享读</h2><p><strong>第一版写错了</strong>，reader 的 V(S)应该放到读数据缓冲区操作前，不然就实现不了不共享读了，已修改。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>, rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>; <span class="comment">//读写互斥</span></span><br><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(S);</span><br><span class="line"></span><br><span class="line">        P(rmutex);</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) P(mutex);</span><br><span class="line">        readCount ++;</span><br><span class="line">        V(rmutex);</span><br><span class="line"></span><br><span class="line">        V(S);</span><br><span class="line"></span><br><span class="line">        读数据放缓冲区；</span><br><span class="line"></span><br><span class="line">        P(rmutex);</span><br><span class="line">        readCount --;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) V(mutex);</span><br><span class="line">        V(rmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">        P(wmutex);</span><br><span class="line">        <span class="keyword">if</span>(writeCount == <span class="number">0</span>) P(S);</span><br><span class="line">        writeCount ++;</span><br><span class="line">        V(wmutex);</span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        写数据进缓冲区；</span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        P(wmutex);</span><br><span class="line">        writeCount --;</span><br><span class="line">        <span class="keyword">if</span>(writeCount == <span class="number">0</span>) V(S);</span><br><span class="line">        V(wmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        <span class="title function_">reader</span><span class="params">()</span>; writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>写者优先的实现：</strong> 假如有一个写者，就不让拿走 S，不让后面的 S 进入。（注意引入 writeCount 的修改方式跟 readCount 是一样的）</p>
<hr>
<p>现在你就成功掌握了互斥、共享、优先这三个方法的实现了。主要包括：</p>
<ul>
<li>读写互斥</li>
<li>读共享+读写互斥 &#x3D; 共享的优先</li>
<li>读共享+读写互斥+读写公平 &#x3D; 按到达时间先后决定优先顺序</li>
<li>读共享+读写互斥+写优先 &#x3D; 不共享的优先</li>
</ul>
<hr>
<h2 id="题目-5-2021-2022-北航-OS-期末理论考试题"><a href="#题目-5-2021-2022-北航-OS-期末理论考试题" class="headerlink" title="题目 5 2021-2022 北航 OS 期末理论考试题"></a>题目 5 2021-2022 北航 OS 期末理论考试题</h2><blockquote>
<p>在新冠疫情期间，某公园实行限流访问，规定每天最多允许 N 个人购票入园。公园的在线售票系统提供了查询余票和在线购票功能，查询者 Q 和购票者 B 分别对余票数量进行读操作和写操作。为了简化问题，假定每次只能购买一张票。请基于 PV 操作设计一个算法，实现多个 Q 和 B 对余票数量的并发访问。要求：<br>（1）Q 和 B 按照到达顺序对余票数量进行访问；<br>（2）当多个 Q 连续到达时，应允许他们并发读取余票数量；<br>（3）当余票为 0 时，不允许 B 执行写操作。</p>
</blockquote>
<blockquote>
<p>解：<br>B 共享票量资源 N，到达顺序优先，Q 共享读</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> bCount = <span class="number">0</span>;<span class="comment">//最多N张票</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">//访问余票数量</span></span><br><span class="line">Semaphore qmutex = <span class="number">1</span>; <span class="comment">//Q共享读</span></span><br><span class="line"><span class="type">int</span> qCount = <span class="number">0</span>; <span class="comment">//Q共享读</span></span><br><span class="line">Semaphore S; <span class="comment">//实现到达顺序优先</span></span><br><span class="line">Q()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(S);</span><br><span class="line"></span><br><span class="line">       P(qmutex);</span><br><span class="line">       <span class="keyword">if</span>(qCount==<span class="number">0</span>) P(mutex);</span><br><span class="line">       qCount++;</span><br><span class="line">       V(qmutex);</span><br><span class="line"></span><br><span class="line">       V(S);</span><br><span class="line"></span><br><span class="line">       查询余票;</span><br><span class="line"></span><br><span class="line">       P(qmutex);</span><br><span class="line">       qCount--;</span><br><span class="line">       <span class="keyword">if</span>(qCount==<span class="number">0</span>) V(mutex);</span><br><span class="line">       V(qmutex);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">B()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(S);</span><br><span class="line"></span><br><span class="line">       P(mutex);</span><br><span class="line">       查询余票</span><br><span class="line">       <span class="keyword">if</span>(bCount==N) 离开；</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           购买；</span><br><span class="line">           bCount++</span><br><span class="line">       &#125;</span><br><span class="line">       V(mutex);</span><br><span class="line"></span><br><span class="line">       V(S);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">   cobegin</span><br><span class="line">       <span class="title function_">Q</span><span class="params">()</span>;B();</span><br><span class="line">   coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<hr>
<h2 id="题目-6-2020-2021-北航-OS-期末理论考试题"><a href="#题目-6-2020-2021-北航-OS-期末理论考试题" class="headerlink" title="题目 6 2020-2021 北航 OS 期末理论考试题"></a>题目 6 2020-2021 北航 OS 期末理论考试题</h2><blockquote>
<p>一个自动生产线上有 4 个机器人（R1-R4）。R1、R2 分别不断生产 2 种不同的零件 X、Y。R3 负责不断将 R1、R2 生产的零件 X、Y 装配成零件 Z。R4 负责不断将零件 Z 加工成成品 P。有一个共享的零件暂存区，最多可以放 10 个零件，每次同时仅允许一个机器人访问这个零件暂存区。所有机器人都要通过零件暂存区传递零件。R1、R2 需要等 R3 将它们之前生产的零件从暂存区中取走后，才能将新生产的零件放入（也就是说，暂存区中零件 X 和 Y 的数量分别都不会大于 1）。请用 PV 操作给出上述 4 个机器人的同步互斥过程，给出信号量（Semaphore）的定义、初值和必要的注释说明。除了信号量外，不应定义其他变量。</p>
<p>说明：</p>
<ul>
<li>R1 的主要动作包括 produceX()、putX()；</li>
<li>R2 的主要动作包括 produceY()、putY()；</li>
<li>R3 的主要动作包括 getX()、getY()、produceZ()和 putZ()；</li>
<li>R4 的主要动作包括 getZ()、produceP()。</li>
<li>上述动作应该包含在同步互斥过程中，并在合适的位置添加相应的信号量的 PV 操作。</li>
<li>上述动作中，只有访问零件暂存区的动作（get 或者 put 开头的）需要互斥访问暂存区，生产动作（produce 开头的）可以并发。</li>
</ul>
</blockquote>
<blockquote>
<p>解：<br>零件缓冲区可放 10 个 full empty，缓冲区互斥读写 mutex，X、Y 最多只能放一个 xempty,xfull,&gt;yempty,yfull</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex=<span class="number">1</span>; <span class="comment">//缓冲区只能允许一个机器人</span></span><br><span class="line">Semaphore empty=<span class="number">10</span>,full=<span class="number">0</span>; <span class="comment">//缓冲区最多能放十个</span></span><br><span class="line">Semaphore xempty=<span class="number">1</span>,xfull=<span class="number">0</span>,yempty=<span class="number">1</span>,yfull=<span class="number">0</span>; <span class="comment">//X、Y最多一个</span></span><br><span class="line">R1()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//produceX</span></span><br><span class="line">      produceX();</span><br><span class="line"><span class="comment">//putX</span></span><br><span class="line">      P(xempty);</span><br><span class="line">      P(empty);</span><br><span class="line">      P(mutex);</span><br><span class="line">      putX();</span><br><span class="line">      V(mutex);</span><br><span class="line">      V(full);</span><br><span class="line">      V(xfull);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">R2()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//produceY</span></span><br><span class="line">       produceY();</span><br><span class="line"><span class="comment">//putY</span></span><br><span class="line">       P(yempty);</span><br><span class="line">       P(empty);</span><br><span class="line">       P(mutex);</span><br><span class="line">       putY();</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(full);</span><br><span class="line">       V(yfull);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">R3()&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//getX</span></span><br><span class="line">      P(xfull);</span><br><span class="line">      P(full);</span><br><span class="line">      P(mutex);</span><br><span class="line">      getX();</span><br><span class="line">      V(mutex);</span><br><span class="line">      V(empty);</span><br><span class="line">      V(xempty);</span><br><span class="line"><span class="comment">//getY</span></span><br><span class="line">      P(yfull);</span><br><span class="line">      P(full);</span><br><span class="line">      P(mutex);</span><br><span class="line">      getY();</span><br><span class="line">      V(mutex);</span><br><span class="line">      V(empty);</span><br><span class="line">      V(yempty);</span><br><span class="line"><span class="comment">//produceZ</span></span><br><span class="line">      produceZ();</span><br><span class="line"><span class="comment">//putZ</span></span><br><span class="line">      P(empty);</span><br><span class="line">      P(mutex);</span><br><span class="line">      putZ();</span><br><span class="line">      V(mutex);</span><br><span class="line">      V(full);</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">R4()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//getZ</span></span><br><span class="line">       P(full);</span><br><span class="line">       P(mutex);</span><br><span class="line">       getZ()</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(empty);</span><br><span class="line"><span class="comment">//produceP</span></span><br><span class="line">       produceP();</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">   cobegin</span><br><span class="line">       <span class="title function_">R1</span><span class="params">()</span>; R2(); R3(); R4();</span><br><span class="line">   coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>感觉有两个资源信号量不需要考虑 PV 的先后顺序（xfull 和 full、xempty 和 empty 这种）？<br>以及做的时候感觉是题目出的很容易不全面？<br>这里不是很确定（</p>
<hr>
<h2 id="题目-7-2019-2020-北航-OS-期末理论考试题-1"><a href="#题目-7-2019-2020-北航-OS-期末理论考试题-1" class="headerlink" title="题目 7 2019-2020 北航 OS 期末理论考试题 1"></a>题目 7 2019-2020 北航 OS 期末理论考试题 1</h2><blockquote>
<p>1 个仓库最多可以容纳 50 件产品（不分产品类型），每次只允许一个产品进出仓库。甲乙两个车间分别生产 A、B 两种产品并共用上述仓库。如果仓库满了则不能进行新的生产。有 5 个需要 A 产品的客户和 5 个需要 B 产品的客户，分别从仓库提取 A、B 产品。请用 P、V 操作来实现上述甲、乙车间以及 A、B 产品的客户之间的同步与互斥关系。给出伪代码描述，并添加尽量详细的注释，说明使用的信号量含义，以及主要代码含义。</p>
</blockquote>
<blockquote>
<p>解：<br>仓库缓冲区 50 empty full，互斥量 mutex</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore empty=<span class="number">50</span>,full=<span class="number">0</span>;</span><br><span class="line">workshopA()&#123; <span class="comment">//甲</span></span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(empty);</span><br><span class="line">       P(mutex);</span><br><span class="line">       produceA();</span><br><span class="line">       putA();</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(full);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">workshopB()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(empty);</span><br><span class="line">       P(mutex);</span><br><span class="line">       produceB();</span><br><span class="line">       putB();</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(full);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">userA()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(full);</span><br><span class="line">       P(mutex);</span><br><span class="line">       getA();</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(empty);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">userB()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(full);</span><br><span class="line">       P(mutex);</span><br><span class="line">       getB();</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(empty);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">   cobegin</span><br><span class="line">       <span class="title function_">workshopA</span><span class="params">()</span>; workshopB(); userA(); userB(); <span class="comment">//这里不确定要不要写五个userA，不是很&gt;确定这个并行是否需要讨论个数？不过都要求伪代码，摆了 :)</span></span><br><span class="line">   coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<hr>
<h2 id="题目-8-2019-2020-北航-OS-期末理论考试题-2"><a href="#题目-8-2019-2020-北航-OS-期末理论考试题-2" class="headerlink" title="题目 8 2019-2020 北航 OS 期末理论考试题 2"></a>题目 8 2019-2020 北航 OS 期末理论考试题 2</h2><blockquote>
<p>校车问题：乘客来到校车的停车站等待校车。当巴士到达的时候，所有正在等待的乘客调用 boardBus()上车。一旦开始上车，任何新到来的乘客都必须等待下一辆巴士。校车的容量为 50 人，如果有超过 50 个人排队，50 名之外的乘客需要等待下一辆巴士。当所有等待的乘客上车完毕，巴士可以离开（调用 depart()）。如果巴士到达时，没有任何乘客，它就会立刻离开（调用 depart()）。<br>请用 PV 操作编写巴士进程和乘客进程的同步互斥关系，满足上述约束条件。给出伪代码描述，并添加尽量详细的注释，说明使用的信号量含义，以及主要代码含义。</p>
</blockquote>
<blockquote>
<p>解：<br>一旦开始上车，任何新到来的乘客都必须等待下一辆巴士 -&gt; 顺序公平<br>但这里给读写公平的情况有个不同的就是，得等待写者叫，读者才能读，跟共享读有一点区别（感觉不是共享读），所以这里只要一个 mutex 放在资源后就行。共享读是前后有 S，同时有 mutex。<br>校车 缓冲区 50 人 empty full（这里缓冲区指能上 下一班车的人）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> passengerCount=<span class="number">0</span>; <span class="comment">//记录乘客数量</span></span><br><span class="line">Semaphore pmutex=<span class="number">1</span>; <span class="comment">//修改记录乘客数量互斥</span></span><br><span class="line">Semaphore empty=<span class="number">50</span>,full=<span class="number">0</span>; <span class="comment">//用来叫人上车</span></span><br><span class="line">Semaphore mutex=<span class="number">1</span>; <span class="comment">//车从</span></span><br><span class="line">passenger()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(pmutex);</span><br><span class="line">       passengerCount++;</span><br><span class="line">       V(pmutex);</span><br><span class="line"></span><br><span class="line">       P(full);</span><br><span class="line">       P(mutex);</span><br><span class="line">       boardBus();</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(empty);</span><br><span class="line"></span><br><span class="line">       P(pmutex);</span><br><span class="line">       passengerCount--;</span><br><span class="line">       V(pmutex);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">bus()&#123;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">       P(mutex);</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> n = max(<span class="number">50</span>,passengerCount);</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">           depart();</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               V(full);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               P(empty);</span><br><span class="line">           &#125;</span><br><span class="line">           depart();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       V(mutex);</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">   passenger(); bus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<hr>
<h2 id="寿司店问题-作业题"><a href="#寿司店问题-作业题" class="headerlink" title="寿司店问题 作业题"></a>寿司店问题 作业题</h2><blockquote>
<p>假设一个寿司店有 5 个座位，如果你到达的时候有一个空座位，你可以立刻就坐。但是如果你到达的时候 5 个座位都是满的有人已经就坐，这就意味着这些人都是一起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。</p>
</blockquote>
<blockquote>
<p>课程组答案：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">eating = waiting = <span class="number">0</span> <span class="comment">//就餐和等待的顾客数</span></span><br><span class="line">mutex = Semaphore (<span class="number">1</span>)</span><br><span class="line">block = Semaphore (<span class="number">0</span>) <span class="comment">//等待队列</span></span><br><span class="line"></span><br><span class="line">must_wait = False</span><br><span class="line">mutex.wait()</span><br><span class="line"><span class="keyword">if</span> must_wait: <span class="comment">//需要等待所有⼈离开</span></span><br><span class="line">   waiting += <span class="number">1</span></span><br><span class="line">   mutex.signal()</span><br><span class="line">   block.wait() <span class="comment">//在block上睡眠</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment">//可以直接吃，如果就坐后满了，后续需要等待</span></span><br><span class="line">   eating += <span class="number">1</span></span><br><span class="line">   must_wait = (eating == <span class="number">5</span>)</span><br><span class="line">   mutex.signal()</span><br><span class="line"><span class="meta"># eat sushi</span></span><br><span class="line">mutex.wait()</span><br><span class="line">eating -= <span class="number">1</span> <span class="comment">//吃完了</span></span><br><span class="line"><span class="keyword">if</span> eating == <span class="number">0</span>: <span class="comment">//如果最后⼀个顾客，可唤醒block上等待的顾客</span></span><br><span class="line">   n = min(<span class="number">5</span>, waiting) <span class="comment">//最多5个顾客可以吃</span></span><br><span class="line">   waiting -= n</span><br><span class="line">   eating += n</span><br><span class="line">   must_wait = (eating == <span class="number">5</span>) <span class="comment">//reset must_wait</span></span><br><span class="line">   block.signal(n) <span class="comment">//唤醒n个顾客</span></span><br><span class="line">mutex.signal()</span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<p>解：<br>寿司缓冲区 5 eat，记录已到达的人数 pCount<br>这里只有一个主体，不用 empty 和 full 了，用一个 eat 就行</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore eat=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> pCount=<span class="number">0</span>;</span><br><span class="line">Semaphore pmutex=<span class="number">1</span>;</span><br><span class="line">passenger()&#123;</span><br><span class="line"></span><br><span class="line">   P(pmutex);</span><br><span class="line">   pCount++;</span><br><span class="line">   <span class="keyword">if</span>(pCount==<span class="number">5</span>)&#123;</span><br><span class="line">       V(pmutex);</span><br><span class="line">       P(eat);</span><br><span class="line">       eat();</span><br><span class="line">       <span class="keyword">while</span>(pCount&gt;<span class="number">1</span>) ;<span class="comment">//等其他四个吃完了</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123; <span class="comment">//一下子放五个位置出去</span></span><br><span class="line">           V(eat);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       P(pmutex);</span><br><span class="line">       pCount--;</span><br><span class="line">       V(pmutex);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       V(pmutex);</span><br><span class="line"></span><br><span class="line">       P(eat);</span><br><span class="line">       eat();</span><br><span class="line"></span><br><span class="line">       P(pmutex);</span><br><span class="line">       pCount--;</span><br><span class="line">       V(pmutex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">   cobegin</span><br><span class="line">       <span class="title function_">passenger</span><span class="params">()</span>;</span><br><span class="line">   coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
</search>
